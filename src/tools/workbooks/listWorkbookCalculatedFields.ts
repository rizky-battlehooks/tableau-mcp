import { CallToolResult } from '@modelcontextprotocol/sdk/types.js';
import { Ok } from 'ts-results-es';
import { z } from 'zod';

import { getConfig } from '../../config.js';
import { useRestApi } from '../../restApiInstance.js';
import { Server } from '../../server.js';
import { Tool } from '../tool.js';
import { parseWorkbookXml } from './parseWorkbookXml.js';

const paramsSchema = {
  workbookId: z.string(),
  /**
   * Choose the data source for calculated fields.
   * - auto: try TWB XML parsing first; fall back to Metadata API on error
   * - twb-xml: only parse from TWB XML
   * - metadata: only fetch from Metadata API
   * - combined: merge TWB XML and Metadata API results (deduped by name)
   */
  source: z.enum(['auto', 'twb-xml', 'metadata', 'combined']).optional(),
  /**
   * Include a computed summary in the result with counts by datatype/role and a sample subset
   */
  includeSummary: z.boolean().optional(),
  /**
   * Limit for summary sample size (default 20, max 200)
   */
  sampleLimit: z.number().int().positive().max(200).optional(),
  /**
   * If true, only return the summary (no fields array). Forces includeSummary=true implicitly.
   */
  summaryOnly: z.boolean().optional(),
  /**
   * Limit the number of returned field records to help control payload size (default 200, max 2000).
   */
  fieldsLimit: z.number().int().positive().max(2000).optional(),
  /**
   * If true, omit formula text from each field in the fields array (reduces payload size).
   */
  omitFormulas: z.boolean().optional(),
  /**
   * Truncate formula text to this length in the fields array (applied only if omitFormulas is false).
   */
  truncateFormulaLength: z.number().int().nonnegative().max(10000).optional(),
  /**
   * If true, return only essential field properties (name, datatype, role) to minimize payload size.
   */
  minimalFields: z.boolean().optional(),
  /**
   * If true, deduplicate fields by display name (caption), falling back to name. Useful to reduce payload size
   * when the same calculated field label appears multiple times.
   */
  uniqueByDisplayName: z.boolean().optional(),
  /**
   * Deprecated: prefer `source: "twb-xml"` instead
   */
  useDirectParsing: z.boolean().optional(),
};

export const getListWorkbookCalculatedFieldsTool = (
  server: Server,
): Tool<typeof paramsSchema> => {
  const tool = new Tool({
    server,
    name: 'list-workbook-calculated-fields',
    description:
      'Lists calculated fields that belong to the specified workbook. You can query the Metadata API, directly parse the TWB XML, or combine both. Use params: source (auto|twb-xml|metadata|combined), includeSummary, sampleLimit, minimalFields (for large workbooks), uniqueByDisplayName (dedupe by caption/name).',
    paramsSchema,
    annotations: {
      title: 'List Workbook Calculated Fields',
      readOnlyHint: true,
      openWorldHint: false,
    },
    callback: async (
      {
        workbookId,
        source,
        includeSummary = false,
        sampleLimit = 20000,
        summaryOnly = false,
        fieldsLimit = 20000,
        omitFormulas = false,
        truncateFormulaLength = 20000,
        minimalFields = false,
        uniqueByDisplayName = false,
        useDirectParsing = false,
      },
      { requestId },
    ): Promise<CallToolResult> => {
      const config = getConfig();

      const query = `
        query workbookCalculatedFields {
          workbooks(filter: { luid: "${workbookId}" }) {
            luid
            name
            # Workbook-level fields (including local calcs)
            fields {
              name
              __typename
              description
              fullyQualifiedName
              ... on CalculatedField {
                formula
                isAutoGenerated
                hasUserReference
              }
            }
            embeddedDatasources {
              luid
              name
              fields {
                name
                __typename
                description
                fullyQualifiedName
                ... on CalculatedField {
                  formula
                  isAutoGenerated
                  hasUserReference
                }
              }
            }
            upstreamDatasources {
              luid
              name
              fields {
                name
                __typename
                description
                fullyQualifiedName
                ... on CalculatedField {
                  formula
                  isAutoGenerated
                  hasUserReference
                }
              }
            }
          }
        }
      `;

      return await tool.logAndExecute({
        requestId,
        args: { workbookId },
        callback: async () => {
          return new Ok(
            await useRestApi({
              config,
              requestId,
              server,
              jwtScopes: ['tableau:content:read'],
              callback: async (restApi) => {
                // Determine effective source based on params (useDirectParsing is deprecated override)
                const effectiveSource: 'auto' | 'twb-xml' | 'metadata' | 'combined' = useDirectParsing
                  ? 'twb-xml'
                  : (source ?? 'auto');

                const fetchFromMetadata = async () => {
                  const json = await restApi.metadataMethods.graphql(query);
                  const workbooks = json?.data?.workbooks ?? [];
                  const items: Array<{
                    workbookLuid: string;
                    workbookName: string | null;
                    datasourceLuid: string;
                    datasourceName: string | null;
                    name: string;
                    fullyQualifiedName?: string;
                    description?: string | null;
                    formula?: string | null;
                    isAutoGenerated?: boolean | null;
                    hasUserReference?: boolean | null;
                    source: 'embedded' | 'upstream' | 'workbook';
                  }> = [];

                  for (const wb of workbooks) {
                    const wbName = wb?.name ?? null;
                    const wbLuid = wb?.luid as string;

                    // Workbook-level fields
                    for (const f of wb?.fields ?? []) {
                      if (f?.__typename === 'CalculatedField') {
                        items.push({
                          workbookLuid: wbLuid,
                          workbookName: wbName,
                          datasourceLuid: wbLuid,
                          datasourceName: 'Workbook',
                          name: f?.name as string,
                          fullyQualifiedName: f?.fullyQualifiedName as string | undefined,
                          description: (f?.description as string) ?? null,
                          formula: (f?.formula as string) ?? null,
                          isAutoGenerated: (f?.isAutoGenerated as boolean) ?? null,
                          hasUserReference: (f?.hasUserReference as boolean) ?? null,
                          source: 'workbook',
                        });
                      }
                    }

                    const collect = (dsArray: any[], source: 'embedded' | 'upstream') => {
                      for (const ds of dsArray ?? []) {
                        const dsLuid = ds?.luid as string;
                        const dsName = (ds?.name as string) ?? null;
                        for (const f of ds?.fields ?? []) {
                          if (f?.__typename === 'CalculatedField') {
                            items.push({
                              workbookLuid: wbLuid,
                              workbookName: wbName,
                              datasourceLuid: dsLuid,
                              datasourceName: dsName,
                              name: f?.name as string,
                              fullyQualifiedName: f?.fullyQualifiedName as string | undefined,
                              description: (f?.description as string) ?? null,
                              formula: (f?.formula as string) ?? null,
                              isAutoGenerated: (f?.isAutoGenerated as boolean) ?? null,
                              hasUserReference: (f?.hasUserReference as boolean) ?? null,
                              source,
                            });
                          }
                        }
                      }
                    };

                    collect(wb?.embeddedDatasources, 'embedded');
                    collect(wb?.upstreamDatasources, 'upstream');
                  }

                  return { count: items.length, fields: items, source: 'metadata-api' as const };
                };

                const fetchFromXml = async () => {
                  // Get workbook name for reference
                  const workbook = await restApi.workbooksMethods.getWorkbook({
                    workbookId,
                    siteId: restApi.siteId,
                  });

                  // Download the workbook content as XML (TWB)
                  const workbookContent = await restApi.workbooksMethods.downloadWorkbookContent({
                    workbookId,
                    siteId: restApi.siteId,
                    includeExtract: false, // Get XML format
                  });

                  // Parse the XML to extract calculated fields
                  const calculatedFields = parseWorkbookXml(workbookContent);

                  // Convert to the expected format
                  const items = calculatedFields.map((field) => ({
                    workbookLuid: workbookId,
                    workbookName: workbook.name || null,
                    datasourceLuid: workbookId,
                    datasourceName: 'Workbook (TWB)',
                    name: field.name,
                    caption: field.caption || null,
                    datatype: field.datatype || null,
                    role: field.role || null,
                    type: field.type || null,
                    formula: field.formula,
                    source: 'workbook-xml' as any,
                  }));

                  return { count: items.length, fields: items, source: 'twb-xml' as const };
                };

                const computeSummary = (
                  fields: Array<{
                    name: string;
                    caption?: string | null;
                    datatype?: string | null;
                    role?: string | null;
                    type?: string | null;
                    formula?: string | null;
                  }>,
                ) => {
                  const byDatatype: Record<string, number> = {};
                  const byRole: Record<string, number> = {};
                  for (const f of fields) {
                    const dt = (f.datatype ?? 'null') as string;
                    const role = (f.role ?? 'null') as string;
                    byDatatype[dt] = (byDatatype[dt] ?? 0) + 1;
                    byRole[role] = (byRole[role] ?? 0) + 1;
                  }
                  const limit = Math.max(1, Math.min(200, sampleLimit ?? 20));
                  const sample = fields.slice(0, limit).map((f) => ({
                    name: f.name,
                    caption: f.caption ?? null,
                    datatype: f.datatype ?? null,
                    role: f.role ?? null,
                    type: f.type ?? null,
                    // Avoid huge payloads by truncating formulas in summary
                    formula: (f.formula ?? '')?.slice(0, 200),
                  }));
                  return {
                    totalCalculatedFields: fields.length,
                    byDatatype,
                    byRole,
                    sample,
                  };
                };

                // Dedupe helper: by caption (display name) lowercased, fallback to name
                const dedupeByDisplayName = (
                  fields: SummaryField[],
                ): SummaryField[] => {
                  const map = new Map<string, SummaryField>();
                  for (const f of fields) {
                    const keyRaw = (typeof f.caption === 'string' && f.caption.trim().length > 0)
                      ? f.caption
                      : (typeof f.name === 'string' ? f.name : '');
                    const key = keyRaw.trim().toLowerCase();
                    if (!map.has(key)) {
                      map.set(key, f);
                    }
                  }
                  return Array.from(map.values());
                };

                const transformFields = (
                  fields: SummaryField[],
                ): SummaryField[] => {
                  if (summaryOnly) return [];
                  const max = Math.max(1, Math.min(2000, fieldsLimit ?? 200));
                  const limit = fields.slice(0, max);
                  
                  if (minimalFields) {
                    // Return only essential properties to minimize payload size
                    return limit.map((f) => ({
                      name: f.name,
                      datatype: f.datatype ?? null,
                      role: f.role ?? null,
                    }));
                  }
                  
                  if (omitFormulas) {
                    return limit.map((f) => ({ ...f, formula: undefined }));
                  }
                  if (typeof truncateFormulaLength === 'number') {
                    const n = Math.max(0, Math.min(10000, truncateFormulaLength));
                    return limit.map((f) =>
                      typeof f.formula === 'string' && f.formula.length > n
                        ? { ...f, formula: f.formula.slice(0, n) }
                        : f,
                    );
                  }
                  return limit;
                };

                type SummaryField = {
                  name: string;
                  caption?: string | null;
                  datatype?: string | null;
                  role?: string | null;
                  type?: string | null;
                  formula?: string | null;
                  // Allow any extra properties from either source
                  [k: string]: unknown;
                };

                const dedupeByName = (
                  a: SummaryField[],
                  b: SummaryField[],
                ): SummaryField[] => {
                  const map = new Map<string, SummaryField>();
                  const put = (item: SummaryField) => {
                    const key = String(item.name ?? '');
                    if (!map.has(key)) {
                      map.set(key, item);
                    }
                  };
                  // Prefer XML first then fill with metadata
                  for (const it of a) put(it);
                  for (const it of b) if (!map.has(String(it.name ?? ''))) put(it);
                  return Array.from(map.values());
                };

                try {
                  if (effectiveSource === 'twb-xml') {
                    const xml = await fetchFromXml();
                    const base = uniqueByDisplayName ? dedupeByDisplayName(xml.fields as SummaryField[]) : (xml.fields as SummaryField[]);
                    const fields = transformFields(base);
                    const out = { count: fields.length, fields, source: xml.source };
                    const needSummary = includeSummary || summaryOnly;
                    return needSummary ? { ...out, summary: computeSummary(base) } : out;
                  }

                  if (effectiveSource === 'metadata') {
                    const meta = await fetchFromMetadata();
                    const base = uniqueByDisplayName ? dedupeByDisplayName(meta.fields as SummaryField[]) : (meta.fields as SummaryField[]);
                    const fields = transformFields(base);
                    const out = { count: fields.length, fields, source: meta.source };
                    const needSummary = includeSummary || summaryOnly;
                    return needSummary ? { ...out, summary: computeSummary(base) } : out;
                  }

                  if (effectiveSource === 'combined') {
                    const [xml, meta] = await Promise.all([fetchFromXml(), fetchFromMetadata()]);
                    const merged = dedupeByName(xml.fields, meta.fields);
                    const base = uniqueByDisplayName ? dedupeByDisplayName(merged as SummaryField[]) : (merged as SummaryField[]);
                    const fields = transformFields(base);
                    const out = { count: fields.length, fields, source: 'combined' as const };
                    const needSummary = includeSummary || summaryOnly;
                    return needSummary ? { ...out, summary: computeSummary(base) } : out;
                  }

                  // 'auto' mode: try XML first, fall back to metadata
                  try {
                    const xml = await fetchFromXml();
                    const base = uniqueByDisplayName ? dedupeByDisplayName(xml.fields as SummaryField[]) : (xml.fields as SummaryField[]);
                    const fields = transformFields(base);
                    const out = { count: fields.length, fields, source: xml.source };
                    const needSummary = includeSummary || summaryOnly;
                    return needSummary ? { ...out, summary: computeSummary(base) } : out;
                  } catch (error) {
                    console.error('Error parsing workbook XML:', error);
                    const meta = await fetchFromMetadata();
                    const base = uniqueByDisplayName ? dedupeByDisplayName(meta.fields as SummaryField[]) : (meta.fields as SummaryField[]);
                    const fields = transformFields(base);
                    const out = { count: fields.length, fields, source: meta.source };
                    const needSummary = includeSummary || summaryOnly;
                    return needSummary ? { ...out, summary: computeSummary(base) } : out;
                  }
                } catch (e) {
                  // As a last resort, return an empty set with context
                  const emptyFields: SummaryField[] = [];
                  const base = uniqueByDisplayName ? dedupeByDisplayName(emptyFields) : emptyFields;
                  const empty = { count: 0, fields: transformFields(base), source: effectiveSource };
                  const needSummary = includeSummary || summaryOnly;
                  return needSummary ? { ...empty, summary: computeSummary(base) } : empty;
                }
              },
            }),
          );
        },
      });
    },
  });

  return tool;
};
