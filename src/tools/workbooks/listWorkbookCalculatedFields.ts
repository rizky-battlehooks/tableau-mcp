import { CallToolResult } from '@modelcontextprotocol/sdk/types.js';
import { Ok } from 'ts-results-es';
import { z } from 'zod';

import { getConfig } from '../../config.js';
import { useRestApi } from '../../restApiInstance.js';
import { Server } from '../../server.js';
import { Tool } from '../tool.js';
import { parseWorkbookXml } from './parseWorkbookXml.js';

const paramsSchema = {
  workbookId: z.string(),
  useDirectParsing: z.boolean().optional(),
};

export const getListWorkbookCalculatedFieldsTool = (
  server: Server,
): Tool<typeof paramsSchema> => {
  const tool = new Tool({
    server,
    name: 'list-workbook-calculated-fields',
    description:
      'Lists calculated fields that belong to the specified workbook by querying the Metadata API or by directly parsing the TWB file content.',
    paramsSchema,
    annotations: {
      title: 'List Workbook Calculated Fields',
      readOnlyHint: true,
      openWorldHint: false,
    },
    callback: async ({ workbookId, useDirectParsing = false }, { requestId }): Promise<CallToolResult> => {
      const config = getConfig();

      const query = `
        query workbookCalculatedFields {
          workbooks(filter: { luid: "${workbookId}" }) {
            luid
            name
            # Workbook-level fields (including local calcs)
            fields {
              name
              __typename
              description
              fullyQualifiedName
              ... on CalculatedField {
                formula
                isAutoGenerated
                hasUserReference
              }
            }
            embeddedDatasources {
              luid
              name
              fields {
                name
                __typename
                description
                fullyQualifiedName
                ... on CalculatedField {
                  formula
                  isAutoGenerated
                  hasUserReference
                }
              }
            }
            upstreamDatasources {
              luid
              name
              fields {
                name
                __typename
                description
                fullyQualifiedName
                ... on CalculatedField {
                  formula
                  isAutoGenerated
                  hasUserReference
                }
              }
            }
          }
        }
      `;

      return await tool.logAndExecute({
        requestId,
        args: { workbookId },
        callback: async () => {
          return new Ok(
            await useRestApi({
              config,
              requestId,
              server,
              jwtScopes: ['tableau:content:read'],
              callback: async (restApi) => {
                // If useDirectParsing is true, download the workbook and parse it directly
                if (useDirectParsing) {
                  try {
                    // Get workbook name for reference
                    const workbook = await restApi.workbooksMethods.getWorkbook({
                      workbookId,
                      siteId: restApi.siteId,
                    });
                    
                    // Download the workbook content as XML (TWB)
                    const workbookContent = await restApi.workbooksMethods.downloadWorkbookContent({
                      workbookId,
                      siteId: restApi.siteId,
                      includeExtract: false, // Get XML format
                    });
                    
                    // Parse the XML to extract calculated fields
                    const calculatedFields = parseWorkbookXml(workbookContent);
                    
                    // Convert to the expected format
                    const items = calculatedFields.map(field => ({
                      workbookLuid: workbookId,
                      workbookName: workbook.name || null,
                      datasourceLuid: workbookId,
                      datasourceName: 'Workbook (TWB)',
                      name: field.name,
                      caption: field.caption || null,
                      datatype: field.datatype || null,
                      role: field.role || null,
                      type: field.type || null,
                      formula: field.formula,
                      source: 'workbook-xml' as any,
                    }));
                    
                    return { count: items.length, fields: items, source: 'twb-xml' };
                  } catch (error) {
                    console.error('Error parsing workbook XML:', error);
                    // Fall back to Metadata API if direct parsing fails
                    console.log('Falling back to Metadata API...');
                  }
                }
                
                // Use Metadata API (original implementation)
                const json = await restApi.metadataMethods.graphql(query);
                const workbooks = json?.data?.workbooks ?? [];
                const items: Array<{
                  workbookLuid: string;
                  workbookName: string | null;
                  datasourceLuid: string;
                  datasourceName: string | null;
                  name: string;
                  fullyQualifiedName?: string;
                  description?: string | null;
                  formula?: string | null;
                  isAutoGenerated?: boolean | null;
                  hasUserReference?: boolean | null;
                  source: 'embedded' | 'upstream' | 'workbook';
                }> = [];

                for (const wb of workbooks) {
                  const wbName = wb?.name ?? null;
                  const wbLuid = wb?.luid as string;

                  // Workbook-level fields
                  for (const f of wb?.fields ?? []) {
                    if (f?.__typename === 'CalculatedField') {
                      items.push({
                        workbookLuid: wbLuid,
                        workbookName: wbName,
                        datasourceLuid: wbLuid,
                        datasourceName: 'Workbook',
                        name: f?.name as string,
                        fullyQualifiedName: f?.fullyQualifiedName as string | undefined,
                        description: (f?.description as string) ?? null,
                        formula: (f?.formula as string) ?? null,
                        isAutoGenerated: (f?.isAutoGenerated as boolean) ?? null,
                        hasUserReference: (f?.hasUserReference as boolean) ?? null,
                        source: 'workbook',
                      });
                    }
                  }

                  const collect = (dsArray: any[], source: 'embedded' | 'upstream') => {
                    for (const ds of dsArray ?? []) {
                      const dsLuid = ds?.luid as string;
                      const dsName = (ds?.name as string) ?? null;
                      for (const f of ds?.fields ?? []) {
                        if (f?.__typename === 'CalculatedField') {
                          items.push({
                            workbookLuid: wbLuid,
                            workbookName: wbName,
                            datasourceLuid: dsLuid,
                            datasourceName: dsName,
                            name: f?.name as string,
                            fullyQualifiedName: f?.fullyQualifiedName as string | undefined,
                            description: (f?.description as string) ?? null,
                            formula: (f?.formula as string) ?? null,
                            isAutoGenerated: (f?.isAutoGenerated as boolean) ?? null,
                            hasUserReference: (f?.hasUserReference as boolean) ?? null,
                            source,
                          });
                        }
                      }
                    }
                  };

                  collect(wb?.embeddedDatasources, 'embedded');
                  collect(wb?.upstreamDatasources, 'upstream');
                }

                return { count: items.length, fields: items, source: 'metadata-api' };
              },
            }),
          );
        },
      });
    },
  });

  return tool;
};
