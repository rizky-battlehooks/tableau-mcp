import { CallToolResult } from '@modelcontextprotocol/sdk/types.js';
import { Ok } from 'ts-results-es';
import { z } from 'zod';

import { getConfig } from '../../config.js';
import { useRestApi } from '../../restApiInstance.js';
import { Server } from '../../server.js';
import { Tool } from '../tool.js';
import { parseWorkbookXml } from './parseWorkbookXml.js';

const paramsSchema = {
  workbookId: z.string(),
  /**
   * Choose the data source for calculated fields.
   * - auto: try TWB XML parsing first; fall back to Metadata API on error
   * - twb-xml: only parse from TWB XML
   * - metadata: only fetch from Metadata API
   * - combined: merge TWB XML and Metadata API results (deduped by name)
   */
  source: z.enum(['auto', 'twb-xml', 'metadata', 'combined']).optional(),
  /**
   * Include a computed summary in the result with counts by datatype/role and a sample subset
   */
  includeSummary: z.boolean().optional(),
  /**
   * Limit for summary sample size (default 20, max 200)
   */
  sampleLimit: z.number().int().positive().max(200).optional(),
  /**
   * Deprecated: prefer `source: "twb-xml"` instead
   */
  useDirectParsing: z.boolean().optional(),
};

export const getListWorkbookCalculatedFieldsTool = (
  server: Server,
): Tool<typeof paramsSchema> => {
  const tool = new Tool({
    server,
    name: 'list-workbook-calculated-fields',
    description:
      'Lists calculated fields that belong to the specified workbook. You can query the Metadata API, directly parse the TWB XML, or combine both. Use params: source (auto|twb-xml|metadata|combined), includeSummary, sampleLimit.',
    paramsSchema,
    annotations: {
      title: 'List Workbook Calculated Fields',
      readOnlyHint: true,
      openWorldHint: false,
    },
    callback: async (
      {
        workbookId,
        source,
        includeSummary = false,
        sampleLimit = 20,
        useDirectParsing = false,
      },
      { requestId },
    ): Promise<CallToolResult> => {
      const config = getConfig();

      const query = `
        query workbookCalculatedFields {
          workbooks(filter: { luid: "${workbookId}" }) {
            luid
            name
            # Workbook-level fields (including local calcs)
            fields {
              name
              __typename
              description
              fullyQualifiedName
              ... on CalculatedField {
                formula
                isAutoGenerated
                hasUserReference
              }
            }
            embeddedDatasources {
              luid
              name
              fields {
                name
                __typename
                description
                fullyQualifiedName
                ... on CalculatedField {
                  formula
                  isAutoGenerated
                  hasUserReference
                }
              }
            }
            upstreamDatasources {
              luid
              name
              fields {
                name
                __typename
                description
                fullyQualifiedName
                ... on CalculatedField {
                  formula
                  isAutoGenerated
                  hasUserReference
                }
              }
            }
          }
        }
      `;

      return await tool.logAndExecute({
        requestId,
        args: { workbookId },
        callback: async () => {
          return new Ok(
            await useRestApi({
              config,
              requestId,
              server,
              jwtScopes: ['tableau:content:read'],
              callback: async (restApi) => {
                // Determine effective source based on params (useDirectParsing is deprecated override)
                const effectiveSource: 'auto' | 'twb-xml' | 'metadata' | 'combined' = useDirectParsing
                  ? 'twb-xml'
                  : (source ?? 'auto');

                const fetchFromMetadata = async () => {
                  const json = await restApi.metadataMethods.graphql(query);
                  const workbooks = json?.data?.workbooks ?? [];
                  const items: Array<{
                    workbookLuid: string;
                    workbookName: string | null;
                    datasourceLuid: string;
                    datasourceName: string | null;
                    name: string;
                    fullyQualifiedName?: string;
                    description?: string | null;
                    formula?: string | null;
                    isAutoGenerated?: boolean | null;
                    hasUserReference?: boolean | null;
                    source: 'embedded' | 'upstream' | 'workbook';
                  }> = [];

                  for (const wb of workbooks) {
                    const wbName = wb?.name ?? null;
                    const wbLuid = wb?.luid as string;

                    // Workbook-level fields
                    for (const f of wb?.fields ?? []) {
                      if (f?.__typename === 'CalculatedField') {
                        items.push({
                          workbookLuid: wbLuid,
                          workbookName: wbName,
                          datasourceLuid: wbLuid,
                          datasourceName: 'Workbook',
                          name: f?.name as string,
                          fullyQualifiedName: f?.fullyQualifiedName as string | undefined,
                          description: (f?.description as string) ?? null,
                          formula: (f?.formula as string) ?? null,
                          isAutoGenerated: (f?.isAutoGenerated as boolean) ?? null,
                          hasUserReference: (f?.hasUserReference as boolean) ?? null,
                          source: 'workbook',
                        });
                      }
                    }

                    const collect = (dsArray: any[], source: 'embedded' | 'upstream') => {
                      for (const ds of dsArray ?? []) {
                        const dsLuid = ds?.luid as string;
                        const dsName = (ds?.name as string) ?? null;
                        for (const f of ds?.fields ?? []) {
                          if (f?.__typename === 'CalculatedField') {
                            items.push({
                              workbookLuid: wbLuid,
                              workbookName: wbName,
                              datasourceLuid: dsLuid,
                              datasourceName: dsName,
                              name: f?.name as string,
                              fullyQualifiedName: f?.fullyQualifiedName as string | undefined,
                              description: (f?.description as string) ?? null,
                              formula: (f?.formula as string) ?? null,
                              isAutoGenerated: (f?.isAutoGenerated as boolean) ?? null,
                              hasUserReference: (f?.hasUserReference as boolean) ?? null,
                              source,
                            });
                          }
                        }
                      }
                    };

                    collect(wb?.embeddedDatasources, 'embedded');
                    collect(wb?.upstreamDatasources, 'upstream');
                  }

                  return { count: items.length, fields: items, source: 'metadata-api' as const };
                };

                const fetchFromXml = async () => {
                  // Get workbook name for reference
                  const workbook = await restApi.workbooksMethods.getWorkbook({
                    workbookId,
                    siteId: restApi.siteId,
                  });

                  // Download the workbook content as XML (TWB)
                  const workbookContent = await restApi.workbooksMethods.downloadWorkbookContent({
                    workbookId,
                    siteId: restApi.siteId,
                    includeExtract: false, // Get XML format
                  });

                  // Parse the XML to extract calculated fields
                  const calculatedFields = parseWorkbookXml(workbookContent);

                  // Convert to the expected format
                  const items = calculatedFields.map((field) => ({
                    workbookLuid: workbookId,
                    workbookName: workbook.name || null,
                    datasourceLuid: workbookId,
                    datasourceName: 'Workbook (TWB)',
                    name: field.name,
                    caption: field.caption || null,
                    datatype: field.datatype || null,
                    role: field.role || null,
                    type: field.type || null,
                    formula: field.formula,
                    source: 'workbook-xml' as any,
                  }));

                  return { count: items.length, fields: items, source: 'twb-xml' as const };
                };

                const computeSummary = (
                  fields: Array<{
                    name: string;
                    caption?: string | null;
                    datatype?: string | null;
                    role?: string | null;
                    type?: string | null;
                    formula?: string | null;
                  }>,
                ) => {
                  const byDatatype: Record<string, number> = {};
                  const byRole: Record<string, number> = {};
                  for (const f of fields) {
                    const dt = (f.datatype ?? 'null') as string;
                    const role = (f.role ?? 'null') as string;
                    byDatatype[dt] = (byDatatype[dt] ?? 0) + 1;
                    byRole[role] = (byRole[role] ?? 0) + 1;
                  }
                  const limit = Math.max(1, Math.min(200, sampleLimit ?? 20));
                  const sample = fields.slice(0, limit).map((f) => ({
                    name: f.name,
                    caption: f.caption ?? null,
                    datatype: f.datatype ?? null,
                    role: f.role ?? null,
                    type: f.type ?? null,
                    // Avoid huge payloads by truncating formulas in summary
                    formula: (f.formula ?? '')?.slice(0, 200),
                  }));
                  return {
                    totalCalculatedFields: fields.length,
                    byDatatype,
                    byRole,
                    sample,
                  };
                };

                type SummaryField = {
                  name: string;
                  caption?: string | null;
                  datatype?: string | null;
                  role?: string | null;
                  type?: string | null;
                  formula?: string | null;
                  // Allow any extra properties from either source
                  [k: string]: unknown;
                };

                const dedupeByName = (
                  a: SummaryField[],
                  b: SummaryField[],
                ): SummaryField[] => {
                  const map = new Map<string, SummaryField>();
                  const put = (item: SummaryField) => {
                    const key = String(item.name ?? '');
                    if (!map.has(key)) {
                      map.set(key, item);
                    }
                  };
                  // Prefer XML first then fill with metadata
                  for (const it of a) put(it);
                  for (const it of b) if (!map.has(String(it.name ?? ''))) put(it);
                  return Array.from(map.values());
                };

                try {
                  if (effectiveSource === 'twb-xml') {
                    const xml = await fetchFromXml();
                    return includeSummary
                      ? { ...xml, summary: computeSummary(xml.fields) }
                      : xml;
                  }

                  if (effectiveSource === 'metadata') {
                    const meta = await fetchFromMetadata();
                    return includeSummary
                      ? { ...meta, summary: computeSummary(meta.fields) }
                      : meta;
                  }

                  if (effectiveSource === 'combined') {
                    const [xml, meta] = await Promise.all([fetchFromXml(), fetchFromMetadata()]);
                    const merged = dedupeByName(xml.fields, meta.fields);
                    const out = { count: merged.length, fields: merged, source: 'combined' as const };
                    return includeSummary ? { ...out, summary: computeSummary(merged) } : out;
                  }

                  // 'auto' mode: try XML first, fall back to metadata
                  try {
                    const xml = await fetchFromXml();
                    return includeSummary
                      ? { ...xml, summary: computeSummary(xml.fields) }
                      : xml;
                  } catch (error) {
                    console.error('Error parsing workbook XML:', error);
                    const meta = await fetchFromMetadata();
                    return includeSummary
                      ? { ...meta, summary: computeSummary(meta.fields) }
                      : meta;
                  }
                } catch (e) {
                  // As a last resort, return an empty set with context
                  const empty = { count: 0, fields: [] as any[], source: effectiveSource };
                  return includeSummary ? { ...empty, summary: computeSummary([]) } : empty;
                }
              },
            }),
          );
        },
      });
    },
  });

  return tool;
};
